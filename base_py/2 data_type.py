#__author__ = 'Winston'
#date: 2020/3/31

# 字符串
#-----------------------------------------------------------------------
str1 = 'aabbccdd'
str2 =str('aabbccdd' ) #本质

# 取值[] 切片 [ : : ] (顾头不顾尾)
# 长度 len
# 成员运算符 in  not in
# strip()默认移除首尾空格 可指定
# split()默认按空格分隔
# for xx in str1 取出每个字符


# strip lstrip rstrip
# lower  upper
# startswith 判断是否以开头  endswith判断是否以结尾
# 格式化输出之format
# split,rsplit 正着切与反着切 可以指定次数
# join 从可迭代对象中取出多个字符串，然后按照指定的分隔符进行拼接，拼接的结果为字符串
# replace 替换 可以指定次数
# isdigit 判断是否是纯数字


# find,rfind,index,rindex,count
#center,ljust,rjust,zfill
#expandtabs
# captalize,swapcase,title
#isnumberic isalnum  isalpha  islower  isupper isspace istitle
#----------------------------------------------------------------------------


# 列表
#------------------------------------------------------------------
list1 = [1,2,['a','b']]
list2 = list((1,2,['a','b'])) # 本质
# # 但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，
# list()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中
# 取值[] 切片(顾头不顾尾)
# 长度 len
# 成员运算in和not in
# append 列表尾部追加元素
# extend 一次性在列表尾部添加多个元素
# insert 在指定位置插入元素
# del
# pop()默认删除列表最后一个元素，并将删除的值返回，括号内可以通过加索引值来指定删除元素
# remove()括号内指名道姓表示要删除哪个元素，没有返回值
# reverse()颠倒列表内元素顺序
# sort()给列表内所有元素排序 相同数据类型

# 字符串，列表都能比较大小 按对应元素值来比较 分出大小就停止比较
# 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大

# 正反向步长 [::1] [::-1]
#通过索引翻转列表 [0:0:-1]
#-------------------------------------------------------------------------

# 元组
#-------------------------------------------------------------------------

#元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改

countries1 = ("中国","美国","英国")
countries2 = tuple(('中国', '美国', '英国')) #本质
# 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组
# 按索引取值
# 切片(顾头不顾尾)
# 长度
# 成员运算in 和 not in
# 循环
#------------------------------------------------------------------------

#字典
#------------------------------------------------------------------------
# 在{}内用逗号分隔开多元素，每一个元素都是key:value的形式，其中value可以是任意类型，而key则必须是不可变类型
info1={'name':'tony',
      'age':18,
      'sex':'male',
      'hobby':{
          'book':'sc',
          'run': 'sn'
      }}
info2 = dict({'name':'tony',
      'age':18,
      'sex':'male',
      'hobby':{
          'book':'sc',
          'run': 'sn'
      }})  # 本质

# 类型转换
info=dict([['name','tony'],('age',18)]) #从3.7开始 字典有序

{}.fromkeys(('name','age','sex'),None)


# 取
hobby_book = info1['hobby']['book']

# 对于赋值操作，如果key原先存在于字典，则会修改对应value的值
info1['hobby']['music'] = 'lc'

# 长度len
# 成员运算in和not in
# info.pop('name')  # 通过指定字典的key来删除字典的键值对
# 获取所有keys info.keys()
# 获取所有value  info.values()

# 获取字典所有键值对 info.items()
# 循环 默认只遍历key

# get() key存在，
# 则获取key对应的value值
# key不存在，不会报错而是默认返回None
# key不存在时，可以设置默认返回的值

# pop() 删除指定的key对应的键值对,并返回值
# popitem() 随机删除一组键值对,并将删除的键值放到元组内返回

# update()  有则修改，无则添加
# fromkeys()  dic = dict.fromkeys(['k1','k2','k3'],[])
# setdefault() key不存在则新增键值对，并将新增的value返回
# key存在则不做任何修改，并返回已存在key对应的value值


# 集合
#---------------------------------------------------------------
# 集合主要用于：去重、关系运算

# 定义：在{}内用逗号分隔开多个元素，集合具备以下三个特点：
#      1：每个元素必须是不可变类型
#      2：集合内没有重复的元素
#      3：集合内元素无序

set1 = {1,2,3,4}
# 集合类型既没有索引也没有key与值对应，所以无法取得单个的值
# d = {} # 默认是空字典
# s = set() # 这才是定义空集合
# # 但凡能被for循环的遍历的数据类型（强调：遍历出的每一个值都必须为不可变类型）都可以传给set()转换成集合类型

# 关系运算
friends1 = {"zero","kevin","jason","egon"} # 用户1的好友们
friends2 = {"Jy","ricky","jason","egon"}   # 用户2的好友们
# 合集(|)：
failarmy=friends1 | friends2
# 交集(&):
intersection = friends1 & friends2
# 差集(-)：
subtraction = friends1 - friends2 # friends1独有的好友
# 对称差集(^) # 求两个用户独有的好友们（即去掉共有的好友）
symmetric_set_difference = friends1 ^ friends2
# 值是否相等(==)
# 父集：一个集合是否包含另外一个集合  >
# 子集 <

# 去重
# 1. 只能针对不可变类型
# 2. 集合本身是无序的，去重之后无法保留原来的顺序

l1 = [7,5,1,'a',2,3,4,5,6,5,4,3,2,1]
s1 = set(l1)
l2 = list(s1) # 按从小到大按ASCII排序

l3 = []
for value in l1:
    if value not in l3:
        l3.append(value) # 顺序不变

# 长度 len
# 成员运算 in not in
# 循环

#---------------------------------------------------------------------

# 总结
# 可变数据类型：值发生改变时，内存地址不变，即id不变，证明在改变原值
# 不可变类型：值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值

#扩展
# enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合
# 为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中